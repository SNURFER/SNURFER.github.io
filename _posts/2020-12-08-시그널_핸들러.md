# 시그널

---

### SIGNAL 

의미를 전달하는 방법은 메세지와 신호가 있을 수 있다. 컴퓨터에서도 특정 이벤트가 발생했을 때, 이에 대한 정보를 알려주는 것을 시그널이라고 한다. 

우리가 무의식적으로 쓰는 리눅스 환경 터미널에서 우리가 무의식적으로 쓰는 ctrl + c라던가  윈도우 환경에서의 alt + F4와 같은 것이 대표적인 예가 될 수 있다. 위의 특정 이벤트가 들어왔을 때, 프로그램에게 강제 종료 시그널을 발생시켰다고 이해할 수 있다. 



## 시그널의 성질

* 비신뢰성 
  * 시그널이 제대로 도착했는지 잘 전달되었는지 확인하지 않음
* 시그널의 예
  * 연산 오류, 자식 프로세스 종료, 사용자의 종료 요청
* 인터럽트라고도 불린다.
* 대기하지 않음
  * 용도가 유한하게 분류되어 있으며, 동시에 시그널이 발생하면 이전 시그널이 무시될 수 있다. 



## 리눅스에서의 시그널 

리눅스 환경에서는 kill, raise, killpg, pthread_kill, tgkill, sigqueue 등과 같은 다양한 시그널을 보내는 방법이 있다. 자세한 동작 옵션은 man 페이지를 보면 확인이 가능하다.

그 중에서도 우리는 특정 프로세스를 죽일 때 다음과 같은 명령어를 무의식적으로 쓰고는 한다.

```
kill -9 [PID]
```

실제로 kill command는 특정 pid에게 signal을 보내는 동작으로 정의되고 있다. 

그 중 "9" 는 리눅스 시그널 종류들 중 9번 항목을 의미하고 이는 SIGKILL이다. 따라서 해당 [PID]에게 SIGKILL 시그널을 보내서 강제 종료시키는 행위로 해석 될 수 있다. 



## 시그널의 종류

UNIX/LINUX 시스템마다 시그널의 종류는 조금씩 차이가 있는데 SIGKILL(9), SIGSEGV(11), SIGTERM(15) 등의 기본적인 시그널은 동일하다. 

* SIGKILL : process를 kill하기 위한 signal
  * 바로 즉각적으로 프로그램이 종료됨
* SIGSEGV : invalid memory reference
  * 비정상 종료 이슈 중 많이 나오는 Segmentation Fault라고 뜨는 메모리 엑세스 오류가 이것이다. 
* SIGTERM : kill 시스템 호출이 보내는 software termination signal
  * SIGKILL과는 대조적으로 자식 프로세스에게 종료전 정보전달이 가능하다고 함



## 시그널 핸들러

---

시그널 핸들러는 위에 설명된 것 이외에도 정의된 다양한 시그널들(자세한건 kill -l 을 이용해서 시그널 확인) 이 프로세스로 전달되면 호출되는 함수이다. 

시그널 핸들러의 실행은 언제든지 메인 프로그램의 흐름을 멈출 수 있다. 커널은 프로세스를 위해 핸들러를 호출하고, 핸들러가 리턴될 때 프로그램은 인터럽트 된 것에서 부터 다시 연산을 수행한다. 



### signal.h

![스크린샷 2020-12-08 오후 11.35.13](/Users/isido/Library/Application Support/typora-user-images/스크린샷 2020-12-08 오후 11.35.13.png)

앞서 설명한 프로세스로 전달되면 호출되는 함수는 signal.h의 signal, sigaction함수를 이용하면 된다. 

signal 함수의 경우 해당 signal에 대한 수행 함수 func를 정의하여 호출되도록 할 수 있다. '

하지만 에러를 반환하는 경우가 두가지 존재한다. 

* signal 에 해당하는 integer가 잘못된 값이
* 핸들러를 달 수 없는 시그널인 경우

해당 케이스도 manual에 다음과 같이 설명이 되어있다. 

![스크린샷 2020-12-08 오후 11.37.27](/Users/isido/Desktop/스크린샷 2020-12-08 오후 11.37.27.png)

